# 编译原理

Hello！你好!欢迎你和我一起学习！在这里，我们以一道面试题作为学习的开端。

这道面试题是这样的: 请你解释下面的这行代码。

```javascript
var name = "jack"
```

不要怀疑，这是真的面试题，而且我当初还碰到了！当时我的心里有一万条草泥马跑过，这他妈的是什么题？这能是什么？这不就是声明变量加赋值吗！这个沙雕面试官...  
面试后在面试后我厚着脸皮问了一下，面试官说是在考察我编译原理和作用域相关的知识。

面试后我在`你不知道的JavaScript`中找到了这一块的知识点，所以在这里整理出来。

下面，跟着我乘坐哆啦A梦的口袋，进入到编译原理的世界来吧！

---

### 传统语言的编译过程

我们先认识一下传统编程语言（这是所说的传统编程语言为C、C艹）的编译流程，程序的代码在执行前一般情况下会有三个步骤。

#### 第一步

分词/词法分析\(Tokenizing/Lexing\)

在这个过程中，会把你的代码当作**字符串**分解为**有意义的代码块**,这些代码块就被称为`词法单元(token)`。  
举个栗子:

```javascript
var a = 1;
```

这个程序通常分解为\[var，a，=，1，;\]。

而空格是否会当作`词法单元`则取决于空格在程序中有没有特殊的意义。比如`python`靠缩进来控制代码的执行。

```json
[
    {
        "type": "Keyword",
        "value": "var"
    },
    {
        "type": "Identifier",
        "value": "a"
    },
    {
        "type": "Punctuator",
        "value": "="
    },
    {
        "type": "Numeric",
        "value": "1"
    }
]
// 被解析后的词法单元
```

#### 第二步

解析/语法分析\(Parsing\)

这个过程是将`词法单元`转换为一个逐级嵌套的语法树。这个树会被称为"**抽象语法树**"\(Abstract Syntax Tree,AST\)。

举个栗子:

```javascript
var a = 1
```

在`var a = 1`的抽象语法树中会有一个叫做`VariableDeclaration`的顶级节点，接下来是一个叫做`Identifier`的子节点，还有一个叫做`init`的子节点，在`init`里面则有一个叫做`value`的子节点，它的值为`1`。

如果上面的的你看不懂的话没关系，实际上我看着也非常绕，特别是我的书写的能力不太好，所以我在下面放了一段代码，让你看个清晰！

```JSON
{
    "type": "Program",
    "body": [
        {
            "type": "VariableDeclaration",
            "declarations": [
                {
                    "type": "VariableDeclarator",
                    "id": {
                        "type": "Identifier",
                        "name": "a"
                    },
                    "init": {
                        "type": "Literal",
                        "value": 1,
                        "raw": "1"
                    }
                }
            ],
            "kind": "var"
        }
    ],
    "sourceType": "script"
}
```

这时候，在把AST转换为可执行代码的过程叫做代码生成。这个过程和语言、目标平台是有关系的。

#### 第三步

目标代码生成

在这里，编译器会将我们上个步骤所生成的语法树进行**目标代码生成。**

举个栗子：

我使用**JavaScript**写了一个程序，但是我想让他在Linux中不需要**Node**环境的支持也可以运行，那么我可以把我的js代码转译为二进制，供Linux直接运行，其最终目的就是**目标代码生成**，编译器会将AST语法树转换为二进制代码。



到这里，最基础的编译过程已经结束了，我们只要简单的了解其流程就可以，像编译器对代码的优化等等很多步骤就不再介绍了，因为我们只需要这些东西帮助我们学习JavaScript。



如果到这里还有些迷糊的话，我在下面放了一张简单的图，帮助你理解。

![](/assets/bianyi.png)

先放开细节，简单来说就是有一种方法，能把`var a = 1`的AST转化为机器指令，用来创建变量、分配内存、分配值等等...

在这里我们只是非常简单的说一下基本的步骤，比起传统语言，`JavaScript`的引擎要复杂一些。

举个栗子：  
由于`JavaScript`是直接在浏览器中编译执行的，所以不会有`大量的`时间在编译阶段进行优化，不像传统语言一样，比如`JAVA`会在编译为字节码阶段对代码进行优化，所以大部分情况发生在代码执行前的几微秒甚至更短的时间.

举个栗子：  
任何的`JavaScript`在执行前都会由**编译器**进行编译，然后做好执行的准备，通常情况下会马上执行。

### 作用域

---

**预警**

这里的作用域我们会深入到编译器层次进行分析。

为了方便你观看，我会安排**三个人物以对话的方式**来解释作用域。

* 引擎  
  负责`JavaScript`程序的编译和执行过程。

* 编译器  
  负责语法分析及代码生成

* 作用域  
  负责收集并维护声明的变量（标识符），并组成一系列的查询，他有一套非常严格的规则，**确定当前所执行的代码是否对这些标识符有访问权限**。

**下面让我们来演一场戏。**

请记着，一名出色的演员就是要代入角色，在这里，我们要把自己想象为引擎。没错，我就是引擎，我就是编译器，我就是作用域！！！

#### var a = 1

```javascript
var a = 1
```

大家好，我是王大锤，我是一个老实的引擎，我看到上面有一行代码，这是两个完全不同的声明，一个由**编译器在编译时处理**，另一个是由**引擎在运行时处理**。

大家好，我叫**编译器**，我是一个老实的编译器，我遇到了`var a`，她是如此的优雅，于是我向`作用域`问了问她的情况，在我当前的作用域中是不是有一个叫做`a`的女孩，如果她存在的话那么我就忽略在声明一个`a`，继续向下编译，如果没有的话那我就会要求作用域在当前的作用域下面声明一个变量，她叫`a`。

大家好，我叫**编译器**，没错，还是我。在接下来的步骤中，我会给`引擎`生成运行时所需要的代码，

大家好，我是**引擎**，我是一个老实的引擎。`编译器`给了我一段可以运行的代码，我看到了，他是给一个变量`a`进行赋值的操作，我可不知道这个`a`在哪里，所以我需要向`作用域`问问。

大家好，我是**作用域**，引擎向我打听一个女孩，这个女孩叫`a`，啊！我看到了！`a`在这里，于是我把`a`的位置丢给了引擎。

引擎：咦？**作用域**老哥终于告诉我`a`的位置了，那么我就把这个\(`1`\)给她吧！作为我的表白礼物...

总结一下：变量的赋值操作有**两个动作**

1. **编译器在当前作用域声明一个变量（假设在之前没有这个变量）**

2. **在引擎运行代码的时候引擎会在作用域中查找这个变量，能找到就对它赋值。**

那么，上面的代码可以让我们在浏览器中看到吗，答案是可以的...

把下面这段代码赋值到浏览器输出一下吧！

```javascript
console.log(a)
var a = 1;
// 这段代码可以非常方便的让你理解JavaScript的作用域
```

上面的代码也导致了我们面试中经常出现的问题，那就是

**变量声明提升**

那么接下来，我们会在深入一点，深入一点理解一下。

#### LHS查询和RHS查询



参考资料:

你不知道的JavaScript

[http://esprima.org/demo/parse.html\#](http://esprima.org/demo/parse.html#)

[https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser\_API\#Node\_objects](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects)

